<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>安全数字</title>
  </head>

  <body>
    <h1>安全数字</h1>
    <p>
      参考：
      <a href="https://www.zhihu.com/question/29010688">JavaScript 里最大的安全的整数为什么是2的53次方减一？</a>、 <a href="https://github.com/camsong/blog/issues/9">JavaScript 浮点数陷阱及解法</a>、
      <a href="https://zhuanlan.zhihu.com/p/30917802">单精度浮点数与双精度浮点数</a>
    </p>

    <pre>
计算机里的最基本的存储单位用位(bit)来表示。bit只能用来存储0或1。
稍大一点的单位是字节(Byte，简写为B）。
再大一级的是千字节(Kilo Bytes)，用k来表示。
再大一级的单位是兆字节(Mega Bytes)，用M来表示。一张照片的大小通常为1~3M。
再大一级的单位为G。一部高清电影的大小通常为1~2G。
再大一级的单位为T。

换算关系为：

1B = 8bit
1K = 1024B = 2^10 B
1M = 1024K = 2^20 B
1G = 1024M = 2^30 B
1T = 1024G = 2^40 B</pre
    >

    <p>单精度（float）在计算机中存储占用4字节，32位，有效位数为7位（6位小数+小数点）。</p>
    <p>双精度（double）在计算机中存储占用8字节，64位，有效位数为16位（15位小数+小数点）。</p>
    <p>不管是float还是double，在计算机中的存储都遵循IEEE规范，使用二进制科学计数法，都包含三个部分：符号位、指数位和尾数部分。其中float的符号位、指数位（即整数部分）、尾数部分分别为1, 8, 23。双精度则分别为1, 11, 52。</p>

    <p>sign（S）：符号位，0是正数，1是负数</p>
    <p>exponent（E）：指数位</p>
    <p>fraction（F）：有效数字，IEEE754规定，在计算机内部保存有效数字时，默认第一位总是1，所以舍去，只保留后面的部分。比如保存1.01，只存01，等读取的时候再把第一位1加上去。所以52位有效数字实际可以存储53位。</p>

    <p><strong>最大安全整数为双浮点数的尾数52位都为1，即等于 2^53-1 。超过这个数将丢失精度。</strong></p>
    <br />
    <p>指数位最大值为2047，二进制为 '11111111 111'，由于科学计数法指数可以为负数，所以去掉一个中间数1023，0-1022表示负数，1024-2047表示正数。</p>
    <p>所以双精度浮点数最大值为 1.7976931348623157e+308 ，超过该值将表示为 Infinity 。<i>在浏览器控制台中输入 1.7976931348623158e+308 打印的结果是 1.7976931348623157e+308 。</i></p>

    <script>
      const maxNum = Math.pow(2, 53) - 1;
      const binaryMaxNum = maxNum.toString(2);

      console.log('maxNum: ', maxNum);
      console.log('binaryMaxNum: ', binaryMaxNum);
      console.log('binaryMaxNum length: ', binaryMaxNum.length);
      console.log('科学计数法 binaryMaxNum: ', '1.1111111111111111111111111111111111111111111111111111e52');

      // 整数位始终为1，可以舍去。得到尾数 1111111111111111111111111111111111111111111111111111

      console.log('尾数: ', '1111111111111111111111111111111111111111111111111111');

      const sign = '0'; // 符号 0-正数 1-负数
      const exponent = (52 + 1023).toString(2); // 指数

      console.log('指数位: ', exponent);
      console.log('64位表示为: ', sign + exponent + binaryMaxNum.substring(1));

      // 最大安全整数为双浮点数的尾数52位都为1，即等于 2^53-1 。超过这个数将丢失精度。

      // 52位1 + 51位0和1位1
      // "1111111111111111111111111111111111111111111111111111" + "0000000000000000000000000000000000000000000000000001"
      // 注意结果有53位，显然是要进位的
      // "10000000000000000000000000000000000000000000000000000"
      // 把原有的整数加上进位会得到这个结果
      // "10.0000000000000000000000000000000000000000000000000000e52"
      // 整数保留一位后得到新的科学计数法结果，注意尾数有53位0，显然不符合规范
      // "1.00000000000000000000000000000000000000000000000000000e53"
      // 由于尾数最多只能用52位表示，我们需要舍去最后一个0
      // 结果是：整数位一位1，52位尾数均为0，指数是53
      //  "1.0000000000000000000000000000000000000000000000000000e53"
      // 虽然2^53次方仍然可以正确标识出来，但是从这里开始已经出现了精度丢失
    </script>
  </body>
</html>
